{"ast":null,"code":"import * as React from 'react';\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport useOnPreventRemove, { shouldPreventRemove } from './useOnPreventRemove';\n/**\n * Hook to handle actions for a navigator, including state updates and bubbling.\n *\n * Bubbling an action is achieved in 2 ways:\n * 1. To bubble action to parent, we expose the action handler in context and then access the parent context\n * 2. To bubble action to child, child adds event listeners subscribing to actions from parent\n *\n * When the action handler handles as action, it returns `true`, otherwise `false`.\n */\nexport default function useOnAction(_ref) {\n  let {\n    router,\n    getState,\n    setState,\n    key,\n    actionListeners,\n    beforeRemoveListeners,\n    routerConfigOptions,\n    emitter\n  } = _ref;\n  const {\n    onAction: onActionParent,\n    onRouteFocus: onRouteFocusParent,\n    addListener: addListenerParent,\n    onDispatchAction\n  } = React.useContext(NavigationBuilderContext);\n  const routerConfigOptionsRef = React.useRef(routerConfigOptions);\n  React.useEffect(() => {\n    routerConfigOptionsRef.current = routerConfigOptions;\n  });\n  const onAction = React.useCallback(function (action) {\n    let visitedNavigators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    const state = getState();\n\n    // Since actions can bubble both up and down, they could come to the same navigator again\n    // We keep track of navigators which have already tried to handle the action and return if it's already visited\n    if (visitedNavigators.has(state.key)) {\n      return false;\n    }\n    visitedNavigators.add(state.key);\n    if (typeof action.target !== 'string' || action.target === state.key) {\n      let result = router.getStateForAction(state, action, routerConfigOptionsRef.current);\n\n      // If a target is specified and set to current navigator, the action shouldn't bubble\n      // So instead of `null`, we use the state object for such cases to signal that action was handled\n      result = result === null && action.target === state.key ? state : result;\n      if (result !== null) {\n        onDispatchAction(action, state === result);\n        if (state !== result) {\n          const isPrevented = shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, result.routes, action);\n          if (isPrevented) {\n            return true;\n          }\n          setState(result);\n        }\n        if (onRouteFocusParent !== undefined) {\n          // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree\n          // This means we need to focus all of the parent navigators of this navigator as well\n          const shouldFocus = router.shouldActionChangeFocus(action);\n          if (shouldFocus && key !== undefined) {\n            onRouteFocusParent(key);\n          }\n        }\n        return true;\n      }\n    }\n    if (onActionParent !== undefined) {\n      // Bubble action to the parent if the current navigator didn't handle it\n      if (onActionParent(action, visitedNavigators)) {\n        return true;\n      }\n    }\n\n    // If the action wasn't handled by current navigator or a parent navigator, let children handle it\n    for (let i = actionListeners.length - 1; i >= 0; i--) {\n      const listener = actionListeners[i];\n      if (listener(action, visitedNavigators)) {\n        return true;\n      }\n    }\n    return false;\n  }, [actionListeners, beforeRemoveListeners, emitter, getState, key, onActionParent, onDispatchAction, onRouteFocusParent, router, setState]);\n  useOnPreventRemove({\n    getState,\n    emitter,\n    beforeRemoveListeners\n  });\n  React.useEffect(() => addListenerParent === null || addListenerParent === void 0 ? void 0 : addListenerParent('action', onAction), [addListenerParent, onAction]);\n  return onAction;\n}","map":{"version":3,"names":["React","NavigationBuilderContext","useOnPreventRemove","shouldPreventRemove","useOnAction","_ref","router","getState","setState","key","actionListeners","beforeRemoveListeners","routerConfigOptions","emitter","onAction","onActionParent","onRouteFocus","onRouteFocusParent","addListener","addListenerParent","onDispatchAction","useContext","routerConfigOptionsRef","useRef","useEffect","current","useCallback","action","visitedNavigators","arguments","length","undefined","Set","state","has","add","target","result","getStateForAction","isPrevented","routes","shouldFocus","shouldActionChangeFocus","i","listener"],"sources":["C:/Users/marci/Interpretes-de-Libras-2/node_modules/@react-navigation/core/lib/module/useOnAction.js"],"sourcesContent":["import * as React from 'react';\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport useOnPreventRemove, { shouldPreventRemove } from './useOnPreventRemove';\n/**\n * Hook to handle actions for a navigator, including state updates and bubbling.\n *\n * Bubbling an action is achieved in 2 ways:\n * 1. To bubble action to parent, we expose the action handler in context and then access the parent context\n * 2. To bubble action to child, child adds event listeners subscribing to actions from parent\n *\n * When the action handler handles as action, it returns `true`, otherwise `false`.\n */\nexport default function useOnAction(_ref) {\n  let {\n    router,\n    getState,\n    setState,\n    key,\n    actionListeners,\n    beforeRemoveListeners,\n    routerConfigOptions,\n    emitter\n  } = _ref;\n  const {\n    onAction: onActionParent,\n    onRouteFocus: onRouteFocusParent,\n    addListener: addListenerParent,\n    onDispatchAction\n  } = React.useContext(NavigationBuilderContext);\n  const routerConfigOptionsRef = React.useRef(routerConfigOptions);\n  React.useEffect(() => {\n    routerConfigOptionsRef.current = routerConfigOptions;\n  });\n  const onAction = React.useCallback(function (action) {\n    let visitedNavigators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    const state = getState();\n\n    // Since actions can bubble both up and down, they could come to the same navigator again\n    // We keep track of navigators which have already tried to handle the action and return if it's already visited\n    if (visitedNavigators.has(state.key)) {\n      return false;\n    }\n    visitedNavigators.add(state.key);\n    if (typeof action.target !== 'string' || action.target === state.key) {\n      let result = router.getStateForAction(state, action, routerConfigOptionsRef.current);\n\n      // If a target is specified and set to current navigator, the action shouldn't bubble\n      // So instead of `null`, we use the state object for such cases to signal that action was handled\n      result = result === null && action.target === state.key ? state : result;\n      if (result !== null) {\n        onDispatchAction(action, state === result);\n        if (state !== result) {\n          const isPrevented = shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, result.routes, action);\n          if (isPrevented) {\n            return true;\n          }\n          setState(result);\n        }\n        if (onRouteFocusParent !== undefined) {\n          // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree\n          // This means we need to focus all of the parent navigators of this navigator as well\n          const shouldFocus = router.shouldActionChangeFocus(action);\n          if (shouldFocus && key !== undefined) {\n            onRouteFocusParent(key);\n          }\n        }\n        return true;\n      }\n    }\n    if (onActionParent !== undefined) {\n      // Bubble action to the parent if the current navigator didn't handle it\n      if (onActionParent(action, visitedNavigators)) {\n        return true;\n      }\n    }\n\n    // If the action wasn't handled by current navigator or a parent navigator, let children handle it\n    for (let i = actionListeners.length - 1; i >= 0; i--) {\n      const listener = actionListeners[i];\n      if (listener(action, visitedNavigators)) {\n        return true;\n      }\n    }\n    return false;\n  }, [actionListeners, beforeRemoveListeners, emitter, getState, key, onActionParent, onDispatchAction, onRouteFocusParent, router, setState]);\n  useOnPreventRemove({\n    getState,\n    emitter,\n    beforeRemoveListeners\n  });\n  React.useEffect(() => addListenerParent === null || addListenerParent === void 0 ? void 0 : addListenerParent('action', onAction), [addListenerParent, onAction]);\n  return onAction;\n}\n//# sourceMappingURL=useOnAction.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}